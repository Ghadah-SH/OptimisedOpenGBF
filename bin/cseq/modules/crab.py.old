""" Crab encoding for bitvector programs.

Author:
    The Anh Pham, Omar Inverso

Changes:
    2020.05.08  prototype start

To do:
  - so many things

Notes:
  - no global variables in the input program
  - no function definition except for main() (use inliner.py if necessary)
  - no loops (for now) (use unroller.py if necessary)
  - each variable has a unique identifier (hence, no variable shadowing)
  - no control-flow statement except if..then..else (no goto)

"""
import core.module

class crab(core.module.Translator):
	enc = ''  # our Crab encoding as a string

	header  = '#include "../program_options.hpp"\n'
	header += '#include "../common.hpp"\n'
	header += '\n'
	header += 'using namespace std;\n'
	header += 'using namespace crab::analyzer;\n'
	header += 'using namespace crab::cfg;\n'
	header += 'using namespace crab::cfg_impl;\n'
	header += 'using namespace crab::domain_impl;\n'
	header += '\n'
	header += 'z_cfg_t* prog1(variable_factory_t& vfac) {\n'

	footer  = '}\n'
	footer += '\n'
	footer += 'int main(int argc, char** argv) {\n'
	footer += 'bool stats_enabled = true;\n'
	footer += '\n'
	footer += 'variable_factory_t vfac;\n'
	footer += 'z_cfg_t* cfg = prog1(vfac);\n'
	footer += 'crab::outs() << *cfg << "------------------------------------";\n'
	footer += '\n'
	footer += 'run<z_aa_bool_int_t>(cfg, cfg->entry(), false, 1, 2, 20, stats_enabled);\n'
	footer += '\n'
	footer += 'return 0;\n'
	footer += '}\n'


	def loadfromstring(self,string,env):
		super(self.__class__, self).loadfromstring(string,env)
		self.output = self.header+self.enc+self.footer


	def visit_Compound(self,n):
		self.enc += 'z_cfg_t* cfg = new z_cfg_t("in_%s", "out_%s", ARR);\n' % (self.blockid,self.blockid)
		self.enc += 'z_basic_block_t& in_%s = cfg->insert("in_%s");\n'  % (self.blockid,self.blockid)
		x = super(self.__class__, self).visit_Compound(n)
		self.enc += 'z_basic_block_t& out_%s = cfg->insert("out_%s");\n'  % (self.blockid,self.blockid)

		return x


	def visit_Decl(self,n):
		lookup = self.Parser.blockdefid(self.blockid,n.name)

		if lookup is None and n.name != 'main': # function
			self.error("functions are not allowed", snippet=True)
		elif lookup is None and n.name == 'main':
			pass
		elif lookup is '0': # global variable
			self.error("global variables not allowed", snippet=True)
		else:
			#print("---> %s" %n.type.type.bit_size)
			# At this point we are dealing with a variable declaration.
			#z_var x(vfac["x"], crab::INT_TYPE, 32);
			self.enc ='z_var %s(vfac["%s"], crab::INT_TYPE, %s);' % (n.name,n.name,n.type.type.bit_size)

		return super(self.__class__, self).visit_Decl(n)



