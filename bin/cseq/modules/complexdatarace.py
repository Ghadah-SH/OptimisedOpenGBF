import re

import core.module
import core.parser
import core.utils
import pycparser.c_ast
from pycparserext.ext_c_parser import FuncDeclExt


class complexdatarace(core.module.Translator):
    def __init__(self):
        self.visitingfunction = False  # true while vising a function definition
        self.visitingcompound = False  # true while visiting a compound

        self.lvalue = None

        self.mutexes = []
        self.threads = []

        self.reads = []
        self.writes = []

        self.visiting_lhs = False
        self.visiting_rhs = False

        self.arrays = []

        self.__atomicSection = False

        super().__init__()

    def init(self):
        super().extend()

        self.inputparam(
            "data-race-check",
            "Runs the data race module",
            "",
            default=False,
            optional=True,
        )

    def loadfromstring(self, string, env):
        self.dataracecheck = (
            True if self.getinputparam("data-race-check") is not None else False
        )

        if not self.dataracecheck:
            return super().loadfromstring(string, env)

        self.thread_no = self.getinputparam("threads")

        header = core.utils.printFile("modules/data_race_header.c")
        header = header.replace("NTHREADS", str(self.thread_no))

        super().loadfromstring(string, env)

        self.insertheader(header)

    def visit_Assignment(self, n):
        """
        op: =, +=, /= etc.

        Assignment: [op, lvalue*, rvalue*]
        """

        if not self.dataracecheck:
            return super().visit_Assignment(n)

        # self.lvalue = n.lvalue
        # original = super().visit_Assignment(n)
        # self.lvalue = None

        self.visiting_lhs = True
        lvalue = super().visit(n.lvalue)
        self.visiting_lhs = False

        self.visiting_rhs = True
        rvalue = super().visit(n.rvalue)
        self.visiting_rhs = False

        result = lvalue + n.op + rvalue

        # ignore stuff added by previous stages of cseq
        # lhs = result.split(n.op)[0].strip()
        # if not lhs.startswith('__cs_') and self.scope.find('pthread') == -1:
        #     self.writes.add(lhs)

        return "".join([l for l in result.splitlines() if not l.startswith("#")])

    def visit_ID(self, n):
        """
        ID: [name]
        """
        original = super().visit_ID(n)

        if (
            not self.dataracecheck
            or self.is_cseq_metadata(original)  # Skip stuff generated by cseq
            or self.current_scope_is_global()  # Skip global static initializers
            or (not self.is_global_var(n) and not self.is_pointer(original))
            or self.is_a_thread_or_mutex(n)
        ):
            return original

        if self.visiting_rhs or not self.visiting_lhs:
            self.track_read_from(n.name)
        elif self.visiting_lhs:
            self.track_write_to(n.name)

        return original

    def track_write_to(self, s, add_addr_of=True):
        while s[0] == "(" and s[-1] == ")":  # TODO: FIX HACK
            s = s[1:-1]
        elem = "&(%s)" % s if add_addr_of else s
        if elem not in self.writes:
            self.writes.append(elem)

    def track_read_from(self, s, add_addr_of=True):
        elem = "&(%s)" % s if add_addr_of else s
        if elem not in self.reads:
            self.reads.append(elem)

    def stop_tracking_write(self, s, add_addr_of=True):
        elem = "&(%s)" % s if add_addr_of else s
        if elem in self.writes:
            self.writes.remove(elem)

    def stop_tracking_read(self, s, add_addr_of=True):
        elem = "&(%s)" % s if add_addr_of else s
        if elem in self.reads:
            self.reads.remove(elem)

    def current_scope_is_global(self):
        """Returns whether the current scope is global. Duh."""
        return self.currentFunct == ""

    def is_a_thread_or_mutex(self, n):
        """Returns true if n is of type pthread_mutex_t or pthread_t."""
        s = self.threads + self.mutexes
        return (hasattr(n, "name") and n.name in s) or (n in s)

    def is_global_var(self, n):
        # if self.Parser.isglobal('0', n.name): #  and not self.Parser.ispointer(self.blockid, n.name)
        """ "Returns whether the given variable is global."""
        return ("0", n.name) in self.Parser.vars

    def is_in_pthread_aux_function(self):
        return self.scope.find("pthread") != -1

    def is_cseq_metadata(self, s):
        return (
            "__cs_" in s
            and not self.is_pointer(s)
            and "local" not in s
            and "param" not in s
        )

    def is_pointer(self, n):
        current_block = self.Parser.fblock[self.currentFunct]
        # TODO: Cannot use self.blockid here, is this a bug?
        # ispointer also returns true for functions, bug?
        return (
            self.Parser.ispointer(current_block + ".0", n)
            and n not in self.Parser.funcName
        )

    def visit_ArrayRef(self, n):
        """
        Example: a[i]

        ArrayRef: [name*, subscript*]
        """
        # original = super().visit_ArrayRef(n)
        name = super().visit(n.name)
        subscript = super().visit(n.subscript)
        original = "%s[%s]" % (name, subscript)

        if not self.dataracecheck or self.is_cseq_metadata(name):
            return original

        # TODO: Probably need to differentiate here pointers from arrays.
        if self.visiting_rhs or not self.visiting_lhs:
            self.track_read_from(name)
            self.track_read_from(original)
        elif self.visiting_lhs:
            self.track_read_from(name)
            self.track_write_to(original)
            self.stop_tracking_write(name)

        return original

    def visit_StructRef(self, n):
        """
        type: . or ->
        name.field or name->field

        StructRef: [name*, type, field*]
        """
        original = super().visit_StructRef(n)

        if not self.dataracecheck:
            return original

        # find is ruling out also local variables here (which is good)
        if original.find("__cs_") != -1:
            return original

        # There should be no need to handle the -> case,
        # since it seems to be preprocessed out.
        self.track_read_from(original)

        if hasattr(n.name, "expr"):
            struct_name = super().visit(n.name.expr)
            self.stop_tracking_read(struct_name)
            if self.visiting_lhs:
                self.track_write_to(original)
                self.stop_tracking_write(struct_name)
            elif self.visiting_rhs:
                self.track_read_from(original)

        return original

    def visit_Decl(self, n):
        """
        Maybe remove?

        # name: the variable being declared
        # quals: list of qualifiers (const, volatile)
        # funcspec: list function specifiers (i.e. inline in C99)
        # storage: list of storage specifiers (extern, register, etc.)
        # type: declaration type (probably nested with all the modifiers)
        # init: initialization value, or None
        # bitsize: bit field size, or None
        #
        Decl: [name, quals, storage, funcspec, type*, init*, bitsize*]
        """

        if not self.dataracecheck:
            return super().visit_Decl(n)

        if isinstance(n.type, pycparser.c_ast.Struct):
            pass
        elif isinstance(n.type, pycparser.c_ast.ArrayDecl):
            if n.name not in self.arrays:
                self.arrays.append(n.name)
        elif hasattr(n.type, "type") and isinstance(
            n.type.type, pycparser.c_ast.IdentifierType
        ):
            if "pthread_t" in n.type.type.names:
                self.threads.append(n.name)
            if "pthread_mutex_t" in n.type.type.names:
                self.mutexes.append(n.name)

        old = self.visiting_rhs
        self.visiting_rhs = True
        # TODO: check for declarations without initializers
        ret = super().visit_Decl(n)
        self.visiting_rhs = old

        return ret

    def visit_Compound(self, n):
        """
        Compound statement in C99 is a list of block items (declarations or
        statements).

        Compound: [block_items**]
        """

        if not self.dataracecheck:
            return super().visit_Compound(n)

        old = self.visitingcompound
        self.visitingcompound = True

        start = self._make_indent() + "{\n"
        s = ""
        cur_thr_idx = (
            self.Parser.threadIndex[self.scope]
            if self.scope in self.Parser.threadIndex
            else 0
        )
        should_close_atomic_section = False
        if n.block_items:
            for stmt in n.block_items:
                s += self._generate_stmt(stmt)
                
                if len(self.writes) > 1:
                    self.error('Multiple writes on a single statement not supported')
                    
                # This is needed because of metadata from previous modules.
                lines = s.splitlines()

                stmt_line = lines.pop()

                read_writes = self.writes + self.reads


                if len(read_writes) > 0 and not self.__atomicSection:
                    lines.append("__VERIFIER_atomic_begin();\n")
                    should_close_atomic_section = True

                for var_name in read_writes:
                    var_addr = self.name_of_addr_var_for(var_name)

                    lines += [
                        "void* %s = %s;" % (var_addr, var_name),
                    ]

                    asserts = [  # % TODO: Maybe switch from CPROVER_assert to if-then with __verifier_assert?
                        '__CPROVER_assert((__cs_thread_to_write_pos[%d] != %s), "Data race found on %s!");'
                        % (i, var_addr, var_name)
                        for i in range(self.thread_no + 1)
                        if i != cur_thr_idx
                    ]

                    lines += asserts

                for var_name in self.writes:
                    var_addr = self.name_of_addr_var_for(var_name)
                    lines += [
                        "__cs_thread_to_write_pos[%d] = %s;" % (cur_thr_idx, var_addr),
                    ]

                lines.append(stmt_line)  # TODO: Check if ; is needed

                if should_close_atomic_section:
                    lines.append("__VERIFIER_atomic_end();\n")
                    should_close_atomic_section = False

                for var_name in self.writes:
                    var_addr = self.name_of_addr_var_for(var_name)
                    lines += [
                        "__cs_thread_to_write_pos[%d] = 0;" % (cur_thr_idx),
                    ]

                s = "\n".join(lines)

                self.writes = []
                self.reads = []

        end = self._make_indent() + "}\n"

        self.visitingcompound = old

        return start + s + end

    def name_of_addr_var_for(self, var_read):
        name = re.sub(r"[\[\]\.\&\*\(\)]", "_", var_read) + "__"
        name = re.sub(r"[\d\s\+\-\|\>\<]", "", name)
        return name  # TODO: Check

    def is_sizeof(self, op):
        return op == "sizeof"

    def visit_UnaryOp(self, n):
        """
        UnaryOp: [op, expr*]
        """
        expr = super().visit(n.expr)
        original = super().visit_UnaryOp(n)

        if (
            not self.dataracecheck
            or self.is_cseq_metadata(expr)
            or self.is_in_pthread_aux_function()
            or self.is_sizeof(n.op)
            or self.is_a_thread_or_mutex(expr)
        ):
            return original

        # Stuff to ignore:
        # sizeof
        # __cs_
        # stuff containing *?
        # unary -

        # Right now we're just considering ++ and --
        if self.is_unary_inc_or_dec(original):
            self.track_write_to(expr)

        if n.op == "*":
            if self.visiting_rhs or not self.visiting_lhs:
                self.track_read_from(expr)
                self.track_read_from("(%s)" % expr, add_addr_of=False)
            elif self.visiting_lhs:
                self.track_read_from(expr)
                self.track_write_to("(%s)" % expr, add_addr_of=False)
                self.stop_tracking_write(expr)
        elif n.op == "&":
            if self.visiting_rhs:
                self.stop_tracking_read(expr)

        return original

    def is_unary_inc_or_dec(self, original):
        return original.find("++") >= 0 or original.find("--") >= 0

    def is_function_pointer(self, s):
        current_block = self.Parser.fblock[self.currentFunct]
        try:
            # TODO: Implement this without exceptions
            return isinstance(
                self.Parser.vars[(current_block, s.name)].type.type, FuncDeclExt
            )
        except Exception as e:
            return False
        # return s.strip().endswith('()') and '*' in s

    def is_unsupported_pthread_function(self, n):
        return n.name in (
            "pthread_rwlock_rdlock",
            "pthread_rwlock_wrlock",
            "pthread_rwlock_rdlock",
        )

    def visit_FuncCall(self, n):
        """
        # name: Id
        # args: ExprList
        #
        FuncCall: [name*, args*]
        """
        if not self.dataracecheck:
            return super().visit_FuncCall(n)

        if hasattr(n.name, "name"):
            if self.is_unsupported_pthread_function(n.name):
                self.error("%s not supported" % n.name.name, snippet=True, lineno=True)
            if self.is_function_pointer(n.name):
                self.error("Function pointers (%s) not supported." % n.name.name)

        self.visitingfunction = True

        fref = self._parenthesize_unless_simple(n.name)

        if fref == "__VERIFIER_atomic_begin":
            self.__atomicSection = True
        elif fref == "__VERIFIER_atomic_end":
            self.__atomicSection = False

        ret = super().visit_FuncCall(n)

        self.visitingfunction = False

        if fref in ["pthread_mutex_unlock", "pthread_mutex_lock", "pthread_mutex_init"]:
            # If this is a mutex function call, skip processing the reads and writes.
            self.reads.clear()
            self.writes.clear()

        return ret

    def new_method(self, n):
        return n.name.name in ("pthread_rwlock_rdlock", "pthread_rwlock_wrlock")
